from generator.loader import ProtypeLoader
from generator.name import NameUtil, TypeRegEx, make_enum_name, make_enum_value, make_struct_name, make_name_XXX_XXX
import re, os

re_param = re.compile('(const)*\s*(?P<name>[\w\s]*\w)', re.I)

license_tsinstudio = '''/**
This header was generated by `sappheiros` (https://github.com/Tomicyo/sappheiros)
Copyright (c) 2017 Tsin Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
**/
'''

class TemplateGenerator(object):
    'template generator'
    def __init__(self):
        self.ns = ''
        self.type_tree = {}

    def gen(self, templ, outpath=''):
        if isinstance(templ, ProtypeLoader):
            print('generating ...', outpath)
            self.content = templ.__type_dict__
            self.type_tree = templ.type_tree

            dir_ = os.path.dirname(outpath)
            (headername,extension) = os.path.splitext(os.path.basename(outpath))
            if not os.path.exists(dir_) and dir_ != '':
                os.makedirs(dir_)

            import_names = self.gen_imports(templ.imports, self.content, dir_)
            self.ns = templ.namespace
            self.is_cpp = templ.__cpp__

            self.__header__ = open(outpath, 'w')
            self.__header__.write(license_tsinstudio)
            self.__header__.write('\n#ifndef __{0}__\n#define __{0}__\n' .format( headername.upper()) )
            for include in import_names:
                self.__header__.write('#include \"%s.h\"\n' % include)

            self.__header__.write('#include <stdint.h>\n')
            
            self.__header__.write('\ntypedef float float32;\n')

            if templ.__cpp__:
                self.__header__.write('\nnamespace {0}\n{{'.format(self.ns))

            for enum in templ.enums:
                self.write_enum(enum)

            for struct in templ.structs:
                self.write_struct(struct)

            if not templ.__cpp__:
                self.__header__.write('\n#if __cplusplus\n')

            for interface in templ.interfaces:
                self.write_interface_forward_decl(interface)
            self.__header__.write('\n')
            
            for interface in templ.interfaces:
                self.write_interface(interface)

            for function in templ.functions:
                self.write_function(function)

            if len(templ.classes) > 0:
                self.__source__ = open(os.path.join(dir_, headername + '.cpp'), 'w')
                self.__source__.write('#include \"%s.h\"\n' % headername)
                if templ.__cpp__:
                    self.__source__.write('\nnamespace %s \n{\n' % self.ns)

            for class_ in templ.classes:
                self.write_class(class_)

            if len(templ.classes) > 0 and templ.__cpp__:
                self.__source__.write('\n} // end %s\n' % self.ns)
            
            if templ.__cpp__:
                self.__header__.write('\n} // namespace %s' % self.ns)
            else:
                self.__header__.write('\n#endif // __cplusplus\n')

            self.__header__.write('\n#endif // __%s__\n' % headername.upper())
                                    
        else:
            print('Error')

    def gen_imports(self, _import, content_dict, dir_):
        import_names = []
        if _import:
            for import_templ in _import:
                tp = ProtypeLoader(import_templ)
                i_name = ''
                self.content = dict(self.content, **tp.__type_dict__)
                self.type_tree = dict(self.type_tree, **tp.type_tree)
                if '.yml' in import_templ:
                    i_name = import_templ[:-4]
                self.gen(tp, os.path.join(dir_, i_name + '.h'))
                import_names.append(i_name)
        return import_names

    def write_interface_forward_decl(self, interface):
        interface_name = interface['interface']
        self.__header__.write('\nstruct {0};'.format(NameUtil['interface'](self.ns, interface_name)))

    def write_interface(self, interface):
        interface_name = interface['interface']
        real_interface_name = NameUtil['interface'](self.ns, interface_name)
        interface_protype = interface['val']
        #self.__header__.write('\ntypedef {0}_T* {0};\n'.format(real_interface_name))
        interface_head = ''
        # write comment
        if 'comment' in interface_protype:
            self.__header__.write('\n// {0}'.format(interface_protype['comment'])) 
        if 'inherit' in interface_protype:
            inherit_name = interface_protype['inherit']
            real_inherit_name = NameUtil['interface'](self.ns, inherit_name)
            interface_head = '\nstruct {0} : public {1}\n{{\n'.format(real_interface_name, real_inherit_name)
        else:
            interface_head = '\nstruct {0}\n{{\n'.format(real_interface_name)
        if 'functions' not in interface_protype and 'inherit' not in interface_protype:
            return
        self.__header__.write(interface_head)
        if 'functions' in interface_protype:
            for function in interface_protype['functions']:
                if isinstance(function, dict):
                    for (func_name, func_val) in function.items():
                        self.gen_interface_function(func_name, func_val)
                else:
                    self.gen_interface_function(function)
        self.__header__.write('};\n')

    def gen_interface_function(self, func_name, function=None):
        ret = 'void'
        real_func_name = NameUtil['function']('', func_name)
        if not function:
            self.__header__.write('  virtual {0} {1}() = 0;\n'.format(ret, real_func_name))
        else:
            if 'return' in function:
                ret = self.get_real_type_name(function['return'])
            param_list = []
            if 'params' in function:
                params = function['params']
                for param in params:
                    if not param:
                        continue
                    if 'type' not in param:
                        print(param, 'error')
                    param_type = param['type']
                    r_param_type = self.get_real_type_name(param_type)
                    param_list.append(' '.join([r_param_type, param['name']]))

            self.__header__.write('  virtual {0} {1}('.format(ret, real_func_name))
            self.__header__.write(', '.join(param_list))
            self.__header__.write(') = 0;\n')

    def get_real_type_name(self, type_name, ns=None):
        r_type_name = type_name
        real_param_t = re_param.findall(type_name)[0][1]
        if real_param_t in self.content:
            param_t_name = self.content[real_param_t]
            real_param_t_name = NameUtil[param_t_name](self.ns if ns==None else ns, real_param_t)
            #r_type_name = re_param.sub(r'\1 ' + real_param_t_name, type_name) python 3.5
            r_type_name = TypeRegEx.sub('\g<const>'+ real_param_t_name + '\g<pointer>', type_name)

        if r_type_name[0:1] == ' ':
            r_type_name = r_type_name[1:]
        return r_type_name

    def write_function(self, function):
        func_decl = function['val']
        ret = 'void' if 'return' not in func_decl else func_decl['return']
        self.__header__.write('{0} (*{1})'.format(ret, function['function']))
        if 'param' in func_decl:
            self.__header__.write('(')
            paralist = []
            for (param_name, param_t) in func_decl['param'].items():
                paralist.append('{0} {1}'.format(param_t, param_name))
            paralist_str = ', '.join(paralist)
            self.__header__.write(paralist_str+');\n')

    def write_enum(self, enum):
        enum_name = enum['enum']
        val = enum['val']
        enum_vals = val['enums']
        # write comment
        if 'comment' in val:
            self.__header__.write('\n// {0}'.format(val['comment'])) 
        r_enum_name = make_enum_name(self.ns, enum_name)
        self.__header__.write('\ntypedef enum {0}\n{{\n'.format(r_enum_name))
        bit = 1
        for enum_val in enum_vals:
            enum_val_name = make_enum_value(make_name_XXX_XXX(enum_name), enum_val)
            if self.ns:
                enum_val_name = self.ns.upper() + '_' + enum_val_name
            if 'bitmask' in val:
                self.__header__.write('  {0} = {1},\n'.format(enum_val_name, bit))
                bit = bit << 1
            else:
                self.__header__.write('  {0},\n'.format(enum_val_name))
        self.__header__.write('}} {0};\n'.format(r_enum_name))
    
    def write_struct(self, struct):
        struct_name = struct['struct']
        struct_members = struct['val']['members']
        # write comment
        if 'comment' in struct['val']:
            self.__header__.write('\n// {0}'.format(struct['val']['comment']))

        r_struct_name = make_struct_name(self.ns, struct_name)
        self.__header__.write('\nstruct {0}\n{{\n'.format(r_struct_name))

        member_setters = []
        #member_params = []
        member_params_str = []
        init_list_str = []
        for member in struct_members:
            if not member:
                continue
            member_type = member['type']
            member_name = member['name']
            if member_type in self.content:
                member_type = NameUtil[self.content[member_type]](self.ns, member_type)
            elif not self.isBasicType(member_type):
                member_type = self.get_real_type_name(member_type, self.ns)
            self.__header__.write('  {0} {1};\n'.format(member_type, member_name))
            m_func_name = 'set%s' % make_struct_name('', member_name)
            m_func_param = (member_type, member_name)
            m_setter = {
                'func': m_func_name,
                'param': m_func_param
            }
            member_setters.append(m_setter)
            if ',' in member_name:
                sub_member = member_name.split(',')
                for sub in sub_member:
                    r_sub = self.stripHeadSpace(sub)
                    member_params_str.append(' '.join([member_type, '_' + r_sub]))
                    init_list_str.append('{0}(_{0})'.format(r_sub))
            else:
                member_params_str.append(' '.join([member_type, '_' + member_name]))
                init_list_str.append('{0}(_{0})'.format(member_name))

        '''
        self.__header__.write('#if __cplusplus\n')
        # write constructor
        self.__header__.write('  {0}({1})\n  : {2}\n  {{}}\n'.format(r_struct_name, ', '.join(member_params_str), '\n  , '.join(init_list_str)))
        # write member function
        for setter in member_setters:
            if ',' in setter['param'][1]:
                member_names = setter['param'][1].split(',')
                member_name_link = ' '.join(member_names)
                func_name = 'set%s' % make_struct_name('', member_name_link)
                m_func_params = []
                m_func_impl = []
                for m_name in member_names:
                    rm_name = self.stripHeadSpace(m_name)
                    m_func_params.append('{0} _{1}'.format(setter['param'][0], rm_name))
                    m_func_impl.append('{0} = _{0};'.format(rm_name))
                self.__header__.write('\n  {0}& {1}({2})\n  {{\n    {3}\n    return *this;\n  }}\n'.
                    format(r_struct_name, func_name, ', '.join(m_func_params), '\n    '.join(m_func_impl)))
            else:
                self.__header__.write('\n  {0}& {1}({2} _{3})\n  {{\n    {3} = _{3};\n    return *this;\n  }}\n'.
                    format(r_struct_name, setter['func'], setter['param'][0], setter['param'][1]))
        
        self.__header__.write('#endif\n')
        '''
        self.__header__.write('};\n')

    def isBasicType(self, t):
        basicType = ['uint32_t', 'uint64_t', 'float32', 'bool', 'float', 'int32_t']
        return t in basicType

    def stripHeadSpace(self, str_):
        if str_ and str_[0:1] == ' ':
            return self.stripHeadSpace(str_[1:])
        else:
            return str_

    def write_class(self, class_):
        class_name = class_['class']
        class_val = class_['val']
        parent_type_name = ''
        parent_type_ns = ''
        r_cls_name = NameUtil['class'](self.ns if not self.is_cpp else '', class_name)
        if 'inherit' in class_val:
            parent_type = class_val['inherit']
            if '::' in parent_type:
                type_segs = parent_type.split('::')
                len_seg = len(type_segs)
                if len_seg >= 2:
                    parent_type_ns = type_segs[0]
                parent_type_name = type_segs[-1]

                if parent_type_ns in self.type_tree:
                    ptype = self.content[parent_type_name] # return interface / struct
                    pname = NameUtil[ptype](parent_type_ns, parent_type_name)
                    pelem = self.type_tree[parent_type_ns][ptype][parent_type_name]
                    self.__header__.write('\nclass {0} : public {1}\n{{\npublic:\n'.format(r_cls_name, pname))
                    if 'functions' in pelem:
                        for function in pelem['functions']:
                            if isinstance(function, dict):
                                for (func_name, func_val) in function.items():
                                    self.gen_class_function(func_name, function=func_val, class_name=r_cls_name, ns=parent_type_ns)
                            else:
                                self.gen_class_function(function, class_name=r_cls_name, ns=parent_type_ns)
                    # write 'friend class'
                    if 'friends' in class_val:
                        friends_types = class_val['friends']
                        for _f_type in friends_types:
                            self.__header__.write('\n  friend class {0};\n'.
                                format(NameUtil['class'](self.ns if not self.is_cpp else '',
                                _f_type)))

                    # then generate constructor and deconstructor
                    self.__header__.write('private:\n  {0}();\n  ~{0}();\n'.format(r_cls_name))
                    if self.__source__:
                        self.__source__.write('\n{0}::{0}()\n{{\n}}\n'.format(r_cls_name))
                        self.__source__.write('\n{0}::~{0}()\n{{\n}}\n'.format(r_cls_name))

                    if 'holdref' in class_val:
                        hold_refs = class_val['holdref']
                        for h_ref in hold_refs:
                            r_h_ref = NameUtil['class'](self.ns if not self.is_cpp else '', h_ref)
                            self.__header__.write('  {0}* {0}_;\n'.format(r_h_ref))

                    self.__header__.write('};\n')

    def gen_class_function(self, func_name, class_name=None, function=None, ns=None):
        ret = 'void'
        r_ret = ret
        real_func_name = NameUtil['function']('', func_name)
        if not function:
            self.__header__.write('  {0} {1}() override;\n'.format(r_ret, real_func_name))
            if self.__source__:
                self.__source__.write('\n{0} {1}::{2}()\n{{\n}}\n'.format(r_ret, class_name, real_func_name))
        else:
            if 'return' in function:
                ret = function['return']
                r_ret = self.get_real_type_name(ret, ns)
            param_list = []
            if 'params' in function:
                params = function['params']
                for param in params:
                    if not param:
                        continue
                    if 'type' not in param:
                        print(param, 'error')
                    param_type = param['type']
                    r_param_type = self.get_real_type_name(param_type, ns)
                    param_list.append(' '.join([r_param_type, param['name']]))

            self.__header__.write('  {0} {1}('.format(r_ret, real_func_name))
            self.__header__.write(', '.join(param_list))
            self.__header__.write(') override;\n')

            if self.__source__:
                default_ret_statement = ''
                for (ns, val) in self.type_tree.items():
                    for (_type, _type_name_val) in val.items():
                        if ret in _type_name_val:
                            if 'enum' == _type:
                                e_parts = []
                                e_parts.append(ns.upper())
                                eval_parts = ret.upper().split(' ')
                                e_parts.extend(eval_parts)
                                e_parts.append(_type_name_val[ret]['enums'][0].upper())
                                e_val = '_'.join(e_parts)
                                default_ret_statement = '  return ' + e_val + ';\n'
                        elif ret.endswith('*'):
                            default_ret_statement = '  return nullptr;\n'

                self.__source__.write('\n{0} {1}::{2}({3})\n{{\n{4}}}\n'.format(r_ret, class_name, real_func_name, ', '.join(param_list), default_ret_statement))

        